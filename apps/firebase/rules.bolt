// auth helpers

isLoggedIn() { auth.uid !== null }

// general helpers

valueOr(value, defaultValue) { value == null ? defaultValue : value }

// Row count helpers

getRecordAsInt(record) { record == null ? 0 : 1 }
rowCount(record) { valueOr(record.parent().row_count, 0) }
rowCountUpdated(nextRecord, prevRecord) { getRecordAsInt(nextRecord) - getRecordAsInt(prevRecord) == rowCount(nextRecord) - rowCount(prevRecord) }

// target record helpers

isTargetId(record, record_id) { record_id == record.parent().target_record_id }
// The NEW version of the NEW target record. Note: calling prior() on
// the result of nextTargetRecord will get the OLD version of the OLD
// target record, which is probably not what you want.
nextTargetRecord(table) { table[table.target_record_id] }
// The OLD version of the NEW target record.
prevTargetRecord(table) { prior(table)[table.target_record_id] }

// rate limit helpers

getLastResetTime(channel, interval) { channel.limits[interval + ''].last_reset_time }
getLastOpCount(channel, interval) { channel.limits[interval + ''].last_op_count }

isValidOpCount(opCount, maxCount) {
  opCount == valueOr(prior(opCount), 0) + 1 && opCount <= maxCount
}

isRateLimitReset(timestamp, opCount, maxTime) {
  timestamp == now && (prior(timestamp) == null || timestamp > prior(timestamp) + maxTime) && opCount == 0
}

isValidRateLimit(timestamp, opCount, maxTime, maxCount) {
  isValidOpCount(opCount, maxCount) || isRateLimitReset(timestamp, opCount, maxTime)
}

// Verify that the op count has been incremented or the timestamp has been
// reset. Rely on the rules for those fields to determine whether it was 
// valid to do so.
isRateLimitUpdated(timestamp, opCount) {
  timestamp == now || opCount == prior(opCount) + 1
}

allRateLimitsUpdated(channel) {
  isRateLimitUpdated(getLastResetTime(channel, 15), getLastOpCount(channel, 15))
}

//
// path rules
//

path /v3/shared-tables {
  read() { true }
}

path /v3/shared-tables/{channel_id}/server_time/{user_id} is Number {
  write() { auth.uid == user_id }
  validate() { this == now }
}

// TODO(dave): consolidate this "counter" with other per-table metadata,
// including target_record_id and row_count.

path /v3/shared-tables/{channel_id}/counters/{table_name} is Number {
  write() { isLoggedIn() && this != null }
  validate() { this == valueOr(prior(this), 0) + 1 }
}

path /v3/shared-tables/{channel_id}/tables/{table_name}/target_record_id is String {
  write() { isLoggedIn() && this != null }
}

path /v3/shared-tables/{channel_id}/tables/{table_name}/row_count is Number {
  write() { isLoggedIn() && this != null }
  validate() { 
    // require that target record is modified appropriately when row count is modified
    this < 1000 && rowCountUpdated(nextTargetRecord(this.parent()), prevTargetRecord(this.parent()))
  }
}

// the key $record_id is the id of the record. Its value is the json-encoded
// value of the record.
path /v3/shared-tables/{channel_id}/tables/{table_name}/{record_id} is String {
  write() {
    // Specify these rules in write(), because validate() is skipped when data is null
    // (e.g. records are removed).
    isLoggedIn() && isTargetId(this, record_id) && rowCountUpdated(this, prior(this)) && allRateLimitsUpdated(this.parent().parent().parent())
  }
}

// rate limits

type RateLimit {
  last_reset_time: Number
  last_op_count: Number  
}

path /v3/shared-tables/{channel_id}/limits/15 is RateLimit {
  write() { isLoggedIn() && this != null }
  validate() {
    isValidRateLimit(this.last_reset_time, this.last_op_count, 15000, 3)
  }
}

//path /v3/shared-tables/{channel_id}/limits/60 is RateLimit;

//path /v3/shared-tables/{channel_id}/limits/240 is RateLimit;
