// auth helpers

isLoggedIn() { auth.uid !== null }

// general helpers

orZero(value) { valueOr(value, 0) }
valueOr(value, defaultValue) { value == null ? defaultValue : value }
isUnchanged(value) { value == prior(value) }
isIncreased(value) { orZero(value) > orZero(prior(value)) }
isIncreasedBy(value, increment) { orZero(value) >= orZero(prior(value)) + increment}
isNotRemoved(value) { value != null || prior(value) == null }

// Row count helpers

getRecordAsInt(record) { record == null ? 0 : 1 }
sumRowCounts(rowCount) { 
  orZero(rowCount['0']) + orZero(rowCount['1']) + 
  orZero(rowCount['2']) + orZero(rowCount['3']) + 
  orZero(rowCount['4']) + orZero(rowCount['5']) + 
  orZero(rowCount['6']) + orZero(rowCount['7']) + 
  orZero(rowCount['8']) + orZero(rowCount['9']) 
}
rowCount(record) { sumRowCounts(record.parent().row_count) }
rowCountUpdated(nextRecord, prevRecord) { getRecordAsInt(nextRecord) - getRecordAsInt(prevRecord) == rowCount(nextRecord) - rowCount(prevRecord) }

// target record helpers

isTargetId(record, record_id) { record_id == record.parent().target_record_id }
// The NEW version of the NEW target record. Note: calling prior() on
// the result of nextTargetRecord will get the OLD version of the OLD
// target record, which is probably not what you want.
nextTargetRecord(table) { table[table.target_record_id] }
// The OLD version of the NEW target record.
prevTargetRecord(table) { prior(table)[table.target_record_id] }

// rate limit helpers

getRateLimit(channel, interval) { channel.limits[interval + ''] }

isValidInit(limit) {
  prior(limit.last_reset_time) == null &&
  limit.last_reset_time == now &&
  limit.last_op_count == 1 &&
  limit.used_ops == null
}

isValidIncrement(limit, maxCount) {
  isUnchanged(limit.last_reset_time) &&
  isUnchanged(limit.target_op_id) &&
  isNotRemoved(limit.used_ops) &&
  isIncreased(limit.last_op_count) &&
  limit.last_op_count <= maxCount 
}

isValidReset(limit, maxTime) {
  limit.used_ops == null &&
  limit.last_reset_time == now && 
  isIncreasedBy(limit.last_reset_time, maxTime) &&
  limit.last_op_count == 0
}

// The NEW version of the NEW target op.
nextTargetOp(limit) {
  limit.used_ops[limit.target_op_id + '']
}

// The OLD version of the NEW target op.
prevTargetOp(limit) { 
  prior(limit).used_ops[limit.target_op_id + '']
}

isValidUsedOp(limit) {
  isUnchanged(limit.last_op_count) &&
  isUnchanged(limit.last_reset_time) &&
  targetOpUsed(limit) &&
  limit.target_op_id <= limit.last_op_count
}

isValidRateLimit(limit, maxTime, maxCount) {
  isValidInit(limit) ||
  isValidIncrement(limit, maxCount) || 
  isValidReset(limit, maxTime) ||
  isValidUsedOp(limit)
}

targetOpUsed(limit) {
  prevTargetOp(limit) == null && nextTargetOp(limit) == true
}

// Minimal check to ensure the client wrote to each rate limit,
// which will trigger the more thorough validation checks there.
allRateLimitsUpdated(channel) {
  targetOpUsed(getRateLimit(channel, 15)) &&
  targetOpUsed(getRateLimit(channel, 60))
}

//
// path rules
//

path /v3/shared-tables {
  read() { true }
}

path /v3/shared-tables/{channel_id}/server_time/{user_id} is Number {
  write() { auth.uid == user_id }
  validate() { this == now }
}

// TODO(dave): consolidate this "counter" with other per-table metadata,
// including target_record_id and row_count.

path /v3/shared-tables/{channel_id}/counters/{table_name} is Number {
  write() { isLoggedIn() && this != null }
  validate() { this > valueOr(prior(this), 0) }
}

path /v3/shared-tables/{channel_id}/tables/{table_name}/target_record_id is String {
  write() { isLoggedIn() && this != null }
}

path /v3/shared-tables/{channel_id}/tables/{table_name}/row_count {
  write() { isLoggedIn() && this != null }
  validate() { 
    // require that target record is modified appropriately when row count is modified
    sumRowCounts(this) < 1000 && rowCountUpdated(nextTargetRecord(this.parent()), prevTargetRecord(this.parent()))
  }
}

path /v3/shared-tables/{channel_id}/tables/{table_name}/row_count/{bucket} is Number {
  //write() { isLoggedIn() && this != null }
}

// the key $record_id is the id of the record. Its value is the json-encoded
// value of the record.
path /v3/shared-tables/{channel_id}/tables/{table_name}/{record_id} is String {
  write() {
    // Specify these rules in write(), because validate() is skipped when data is null
    // (e.g. records are removed).
    isLoggedIn() && isTargetId(this, record_id) && rowCountUpdated(this, prior(this)) &&
    allRateLimitsUpdated(this.parent().parent().parent())
  }
}

// rate limits

type RateLimits {
  '15': RateLimit | Null
  '60': RateLimit | Null
}

type RateLimit {
  last_reset_time: Number | Null
  last_op_count: Number
  target_op_id: Number | Null
  used_ops: Boolean[]
}

path /v3/shared-tables/{channel_id}/limits is RateLimits {
  write() { isLoggedIn() && this != null }
}

path /v3/shared-tables/{channel_id}/limits/15 {
  validate() {
    isValidRateLimit(this, 15000, 30)
  }
}

path /v3/shared-tables/{channel_id}/limits/60 {
  validate() {
    isValidRateLimit(this, 60000, 60)
  }
}

//path /v3/shared-tables/{channel_id}/limits/240 is RateLimit;
