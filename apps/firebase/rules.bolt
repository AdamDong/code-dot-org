// auth helpers

isLoggedIn() { auth.uid !== null }

// general helpers

orZero(value) { valueOr(value, 0) }
valueOr(value, defaultValue) { value == null ? defaultValue : value }
isUnchanged(value) { value == prior(value) }
isIncreased(value) { orZero(value) > orZero(prior(value)) }
isIncreasedBy(value, increment) { orZero(value) >= orZero(prior(value)) + increment}
isNotRemoved(value) { value != null || prior(value) == null }

// Row count helpers

getRecordAsInt(record) { record == null ? 0 : 1 }
sumRowCounts(rowCount) { 
  orZero(rowCount['0']) + orZero(rowCount['1']) + 
  orZero(rowCount['2']) + orZero(rowCount['3']) + 
  orZero(rowCount['4']) + orZero(rowCount['5']) + 
  orZero(rowCount['6']) + orZero(rowCount['7']) + 
  orZero(rowCount['8']) + orZero(rowCount['9']) 
}
rowCount(record) { sumRowCounts(record.parent().parent().row_count) }
rowCountUpdated(nextRecord, prevRecord) { getRecordAsInt(nextRecord) - getRecordAsInt(prevRecord) == rowCount(nextRecord) - rowCount(prevRecord) }

// target record helpers

isTargetId(record, record_id) { record_id == record.parent().parent().target_record_id }
// The NEW version of the NEW target record. Note: calling prior() on
// the result of nextTargetRecord will get the OLD version of the OLD
// target record, which is probably not what you want.
nextTargetRecord(table) { table[table.target_record_id] }
// The OLD version of the NEW target record.
prevTargetRecord(table) { prior(table)[table.target_record_id] }

// rate limit helpers

getRateLimitCounter(channel, interval) { channel.limits[interval + ''] }
getRateLimitData(channel, interval) { channel.data.limits[interval + ''] }

isValidIncrement(limitCounter, maxCount) {
  isUnchanged(limitCounter.last_reset_time) &&
  isIncreased(limitCounter.last_op_count) &&
  limitCounter.last_op_count <= maxCount 
}

isValidReset(channel, interval) {
  channel.data.limits[interval + ''].used_ops == null &&
  channel.limits[interval + ''].last_reset_time == now && 
  isIncreasedBy(channel.limits[interval + ''].last_reset_time, interval * 1000) &&
  channel.limits[interval + ''].last_op_count == 0
}

// The NEW version of the NEW target op.
nextTargetOp(limitData) {
  limitData.used_ops[limitData.target_op_id + '']
}

// The OLD version of the NEW target op.
prevTargetOp(limitData) { 
  prior(limitData).used_ops[limitData.target_op_id + '']
}

isValidUsedOp(channel, interval) {
  isUnchanged(channel.limits[interval + ''].last_op_count) &&
  isUnchanged(channel.limits[interval + ''].last_reset_time) &&
  targetOpUsed(channel.data.limits[interval + '']) &&
  channel.data.limits[interval + ''].target_op_id <= channel.limits[interval + ''].last_op_count
}

isValidRateLimitData(channel, interval) {
  isValidReset(channel, interval) ||
  isValidUsedOp(channel, interval)
}

isValidRateLimitCounter(channel, interval, maxCount) {
  isValidIncrement(channel.limits[interval + ''], maxCount) || 
  isValidReset(channel, interval)
}

targetOpUsed(limitData) {
  limitData.target_op_id != null &&
  prevTargetOp(limitData) == null && nextTargetOp(limitData) == true
}

// Minimal check to ensure the client wrote to each rate limit,
// which will trigger the more thorough validation checks there.
allRateLimitsUpdated(channel) {
  targetOpUsed(getRateLimitData(channel, 15)) &&
  targetOpUsed(getRateLimitData(channel, 60))
}

//
// path rules
//

path /v3/shared-tables {
  read() { true }
}

path /v3/shared-tables/{channel_id}/server_time/{user_id} is Number {
  write() { auth.uid == user_id }
  validate() { this == now }
}

// The last record id previously assigned to a new record in this table.
// Incremented transactionally. The new value belongs to the caller.
path /v3/shared-tables/{channel_id}/counters/tables/{table_name}/last_id is Number {
  write() { isLoggedIn() && this != null }
  validate() { this > orZero(prior(this)) }
}

path /v3/shared-tables/{channel_id}/data/tables/{table_name}/target_record_id is String {
  write() { isLoggedIn() && this != null }
}

path /v3/shared-tables/{channel_id}/data/tables/{table_name}/row_count {
  write() { isLoggedIn() && this != null }
  validate() { 
    // require that target record is modified appropriately when row count is modified
    sumRowCounts(this) < 1000 && rowCountUpdated(nextTargetRecord(this.parent()), prevTargetRecord(this.parent()))
  }
}

path /v3/shared-tables/{channel_id}/data/tables/{table_name}/row_count/{bucket} is Number;

// the key $record_id is the id of the record. Its value is the json-encoded
// value of the record.
path /v3/shared-tables/{channel_id}/data/tables/{table_name}/records/{record_id} is String {
  write() {
    // Specify these rules in write(), because validate() is skipped when data is null
    // (e.g. records are removed).
    isLoggedIn() && isTargetId(this, record_id) && rowCountUpdated(this, prior(this)) &&
    allRateLimitsUpdated(this.parent().parent().parent().parent().parent())
  }
}

// rate limit counters

type RateLimitCounters {
  '15': RateLimitCounter | Null
  '60': RateLimitCounter | Null
}

type RateLimitCounter {
  last_reset_time: Number | Null
  last_op_count: Number
}

path /v3/shared-tables/{channel_id}/limits is RateLimitCounters {
  write() { isLoggedIn() && this != null }
}

path /v3/shared-tables/{channel_id}/limits/15 {
  validate() {
    isValidRateLimitCounter(this.parent().parent(), 15, 30)
  }
}

path /v3/shared-tables/{channel_id}/limits/60 {
  validate() {
    isValidRateLimitCounter(this.parent().parent(), 60, 60)
  }
}

// rate limit data

type RateLimitDatas {
  '15': RateLimitData | Null
  '60': RateLimitData | Null
}

type RateLimitData {
  target_op_id: Number | Null
  used_ops: Boolean[]
}

path /v3/shared-tables/{channel_id}/data/limits is RateLimitDatas {
  write() { isLoggedIn() && this != null }
}

path /v3/shared-tables/{channel_id}/data/limits/15 {
  validate() {
    isValidRateLimitData(this.parent().parent().parent(), 15)
  }
}

path /v3/shared-tables/{channel_id}/data/limits/60 {
  validate() {
    isValidRateLimitData(this.parent().parent().parent(), 60)
  }
}

//path /v3/shared-tables/{channel_id}/data/limits/240 { }
